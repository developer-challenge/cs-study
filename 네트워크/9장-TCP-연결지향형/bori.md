# 9장 TCP 연결 지향형

## TCP 프로토콜 (Transmittion Control Protocol)

- 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간의 통신을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
- TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 비접속사형 사용자 데이터그램 프로토콜(UDP)을 사용
- TCP는 UDP보다 안전하지만 느리다.

### TCP 프로토콜의 구조

![](https://i.imgur.com/5kFk0Az.png)
![](https://i.imgur.com/iCdPoON.png)

- 출발지 포트 번호(2 bytes)
- 목적지 포트 번호(2 bytes)
- Sequence Number : TCP 패킷의 순서 번호
- Acknowledgment Number : Seq 번호에 대한 응답 번호
- Offset : 헤더의 길이, IP 헤더의 길이와 성격이 비슷, 최대 15, Offset \* 4 = 실제 헤더의 크기
- Reserved : 예약된 필드로 사용하지 않는 필드
- TCP Flags : 현재 패킷의 종류를 표시
- Window : 내 사용 가능 공간이 얼마나 남았는지 알려주는 기능, 남은 버퍼의 크기를 상대방에게 미리 알려주는 기능
- 체크썸 : 헤더의 오류를 확인하기 위한 값
- Urgent Pointer: 어디가 긴급 데이터인지를 가리키는 곳

## TCP 플래그

- 현재 패킷의 종류를 표시

### TCP 플래그의 종류와 기능

- URG : 긴급 bit, 우선순위가 높은 데이터를 포함한 패킷
- ACK : 승인 bit, 승인의 뜻을 포함한 패킷
- PSH : 밀어넣기 bit, TCP Buffer가 일정한 크기만큼 쌓여야 패킷을 추가 전송하는데 이를 생략하고 계속 데이터를 전송하게 함
- RST : 초기화 bit, 상대방과 연결이 된 상태에서 데이터를 주고받는 거에 문제가 발생했으니 서로의 연결을 초기화하겠다는 패킷
- SYN : 동기화 bit, 상대방과 연결을 시작할 때 무조건 사용하는 플래그, Seq 번호를 동기화하고 연결 수립을 요청한다는 패킷
- FIN : 종료 bit, 서버와 클라이언트가 연결을 종료하겠다는 패킷

![](https://i.imgur.com/cfREmSa.png)

## TCP를 이용한 통신과정

### 연결 수립 과정

- TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 **가장 먼저 수행되는 과정**
- 연결하고자 하는 두 장치 간의 논리적 접속을 성립하기 위해 사용하는 연결 확인 방식

1. 클라이언트가 서버에게 요청 패킷을 보냄
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보냄
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보냄

⇒ 3 Way Handshake

### 3 Way Handshake

`[ Eth ][ IPv4 ][ TCP ]` 형태로 페이로드를 포함하지 않는다.

**[클라이언트] ----------- Flag : SYN ----------> [웹 서버]**

- Seq Num: `100`(처음 패킷을 보낼 때는 랜덤 값)
- Ack Num: `0`(처음에는 값이 0)

**[클라이언트] <------- Flag : SYN + ACK ------- [웹 서버]**

- Seq Num: `2000`(처음 패킷을 보낼 때는 랜덤 값)
- Ack Num: `101`(받은 Seq Num + 1)

**[클라이언트] ----------- Flag : ACK ----------> [웹 서버]**

- Seq Num: `101`(받은 Ack Num) ⇒ 동기화가 됨
- Ack Num: `2001`(받은 Seq Num + 1)

> 세션 하이재킹
>
> - 연결 수립 이후 클랑리언트가 아닌 다른 누군가가 위의 값을 계산해서 보내면 클라이언트 대신에 다른 누군가와 서버가 통신하기 시작

### 데이터 송수신 과정

- TCP를 이용한 데이터 통신을 할 때 단순히 TCP 패킷만을 캡슐화해서 통신하는 것이 아닌 **페이로드를 포함**한 패킷을 주고 받을 때의 일정한 규칙

1. 보낸 쪽에서 또 보낼 때는 Seq 번호와 Ack 번호가를 그대로 사용
2. 받는 쪽에서 Seq 번호는 받은 Ack 번호가 된다
3. 받는 쪽에서 Ack 번호는 받은` Seq 번호 + 데이터의 크기

`[ Eth ][ IPv4 ][ TCP ][ Data ]` 형태

**[클라이언트] ------ Flag : PSH + ACK / Req Data: 100 -----> [웹 서버]**

- Seq Num: `101`(이전 값 그대로)
- Ack Num: `2001`(이전 값 그대로)

**[클라이언트] <----- Flag : PSH + ACK / Res Data : 500 ----- [웹 서버]**

- Seq Num: `2001`
- Ack Num: `201`(받은 Seq 번호 + 받은 데이터 크기)

**[클라이언트] ----------------- Flag : ACK ----------------> [웹 서버]**

- Seq Num: `201`(받은 Ack Num)
- Ack Num: `2501`(받은 Seq Num + 받은 데이터 크기)

## TCP 상태전이도

### TCP 연결 상태의 변화

- CLOSED : 연결이 완전히 종료된 상태
- CLOSING : 흔하지 않으나 주로 확인 메시지가 전송 도중 유실된 상태
- CLOSE_WAIT : TCP 연결이 상위 응용프로그램 레벨로부터 연결 종료를 기다리는 상태
- **ESTABLISHED** : 서버와 클라이언트 간에 세션 연결이 성립되어 통신이 이루어지고 있는 상태 (클라이언트가 서버의 SYN을 받아 세션이 연결된 상태)
- FIN_WAIT1 : 클라이언트가 서버에게 연결을 끊고자 요청하는 상태 (FIN을 보낸 상태)
- FIN_WAIT2 : 서버가 클라이언트로부터 연결 종료 응답을 기다리는 상태 (서버가 클라이언트로부터 최초로 FIN을 받은 후 클라이언트에게 ACK를 주었을 때)
- LAST_ACK : 호스트가 원격지 호스트의 연결 종료 요구 승인을 기다리는 상태 (서버가 클라이언트에게 FIN을 보냈을 때의 상태)
- **LISTEN** : 서버가 클라이언트의 접속 요청을 기다리고 있는 상태
- SYN_SENT : 클라이언트가 서버에게 연결을 요청한 상태

### 3 Way Handshake 과정에서의 상태 변화

**[클라이언트] ----------- Flag : SYN ----------> [웹 서버]**

- 클라이언트 상태 : SYN_SENT
- 서버 상태 : SYN_RECEIVED
- Seq Num: `100` / Ack Num: `0`

**[클라이언트] <------- Flag : SYN + ACK ------- [웹 서버]**

- Seq Num: `2000` / Ack Num: `101`

**[클라이언트] ----------- Flag : ACK ----------> [웹 서버]**

- 클라이언트 상태 : ESTABLISHED
- 서버 상태 : ESTABLISHED
- Seq Num: `101` / Ack Num: `2001`
