# 6장 IPv4, ICMP 프로토콜

## IPv4 프로토콜

### IPv4가 하는 일

- 네트워크 상에서 데이터를 교환하기 위한 프로토콜, 20 바이트
- 데이터가 정확하게 전달될 것을 보장하지 않음
  ⇒ 단순히 멀리 보내는 역할만 수행
- 데이터의 정확하고 순차적인 전달은 그보다 상위 프로토콜인 TCP에서 보장
- 중복된 패킷을 전달하거나 패킷의 순서를 잘못 전달할 가능성도 있다.
  ⇒ 악의적으로 이용되면 DoS 공격이 됨

### IPv4 프로토콜의 구조

![](https://i.imgur.com/jbyUGlI.png)

- Version : IP프로토콜의 버전, 일반적으로 4만 온다.
  - IPv6 프로토콜은 구조가 다르다.
- IHL(IP Header Length) : 일반적으로 옵션을 제외한 20바이트, 이를 4로 나눠서 2진수로 표기
- Type of Service(TOS) : 현재는 사용하지 않아 0으로 비워둠
- Total Length : 페이로드까지 합친 크기
- Identification : 조각화가 발생했을 때 각각의 조각들이 원래 하나의 데이터였다는 것을 구분하기위한 ID 값(OS에서 랜덤 생성)
- IP Flags : 조각화가 발생했는지 아닌지, 조각화를 할 것인지 하지 않을 것인지 결정하는 값
  - x : 예약 필드
  - D : Don't 조각화 하지 않겠다 선언
  - m : more 조각화 발생함을 나타냄
- Fragment Offset : 조각화가 발생했을 때 각각의 조각들의 시작 위치를 나타내는 값(시작 위치에서 얼마만큼 떨어져 있는지 나타냄)
- TTL : 네트워크 상에서 패킷의 무한 루프를 방지하기 위한 값, 라우터를 하나 넘어갈 때마다 1씩 감소
- Protocol : 상위 프로토콜이 무엇인지 미리 알려준다. (ICMP:1, TCP:6, UDP:17)
- 헤더 체크썸 : 헤더의 오류를 확인하기 위한 값
- 출발지 IP 주소
- 목적지 IP 주소

## ICMP 프로토콜(Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜)

### ICMP가 하는 일

- 통신 상태를 확인하기 위해서 사용하는 프로토콜, 8바이트
- 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류 메시지를 전송 받는 데 주로 쓰인다.
- 프로토콜 구조의 Type과 Code를 통해 오류 메시지를 전송 받는다.

### ICMP 프로토콜의 구조

![](https://i.imgur.com/Wo0LEEZ.png)

- 타입 : 대분류하기 위한 값
  - `0` : 정상적인 응답 / `8` : 요청
  - `3` : 목적지로 도착 불가능, 목적지까지 도착하지 못한 것(경로 상의 문제)
  - `5` : 리다이렉트, 원격지에서 상대방의 라우팅 테이블 수정
  - `11` : 시간 초과, 목적지까지 갔는데 응답을 받지 못한 것(상대방의 문제)
- 코드 : 소분류하기 위한 값
- 체크썸 : 해당 패킷의 오류를 확인하기 위한 값
- 나머지 : ICMP 프로토콜을 이용하는 프로그램에서 추가하고 싶은 기능을 추가하는 부분

## 라우팅 테이블(Routing table)

- `netstat -r` 명령어로 확인

![](https://i.imgur.com/WX9AuPA.png)

- 송신지와 수신지까지 도달하기 위해 사용되며 라우터에 들어가 있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트
  ⇒ 다른 네트워크 대역을 찾아가기 위한 지도
- 라우팅 테이블에 적혀있는 네트워크 대역만 찾아갈 수 있다.
  ⇒ 지도가 있어야 해당하는 위치에 찾아갈 수 있다.

## 다른 네트워크와 통신 과정

### 다른 네트워크까지 내 패킷의 이동 과정

- 시스템 A와 시스템 B가 다른 네트워크에 있는 경우, A의 라우팅 테이블에 B의 네트워크 대역이 있어야 통신할 수 있다.
- B의 네트워크 대역을 알고 있다면, ICMP 요청 프로토콜 작성
  - 형식 : `[ Eth ][ IPv4 ][ ICMP 요청 ]`

> 이 때, **Ethernet 프로토콜 목적지 MAC 주소**는 어디일까?
> ⇒ Ethernet 프로토콜은 가까운 곳을 통신하는 프로토콜이므로 가까운 곳의 MAC 주소를 목적지로 작성한다. 따라서 게이트웨이의 MAC 주소가 들어간다.

- 공유기에 도달하여 공유기의 라우팅 테이블 확인
  - Ethernet 프로토콜을 자신이 통신할 수 있는 네트위크 대역으로 다시 작성
- 라우터에 도달하여 라우터의 라우팅 테이블 확인
  - Ethernet 프로토콜을 다시 작성
    ⇒ Ethernet 프로토콜은 네트워크 대역이 바뀔 때마다 다시 작성
- 시스템 B에 도달하여 ICMP 요청 확인
  - 응답 프로토콜 작성하여 응답

## IPv4의 조각화

### 조각화란?

- 큰 IP 패킷들이 적은 MTU(Maximum Transmission Unit)를 갖는 경로를 통하여 전송되려면 **여러 개의 작은 패킷으로 쪼개어/조각화 되어 전송**되어야 함
- 즉, 목적지까지 패킷을 전달하는 과정에 통과하는 각 라우터마다 전송에 적합한 프레임으로 변환이 필요
- 일단 조각화되면, 최종 목적지에 도달할 때가지 재조립되지 않는 것이 일반적
- IPv4에서는 발신지 뿐만 아니라 중간 라우터에서도 IP 조각화 가능
- IPv6에서는 IP 단편화가 발신지에서만 가능, 재조립은 항상 최종 수신지에서만 가능

### 조각화하는 과정

![](https://i.imgur.com/Ziz6ZLV.png)

- 전송하려는 데이터 : `[ IPv4 프로토콜 20 bytes][ Data 11,980 bytes ]` = 총 12,000 bytes
- MTU : 3,300-Byte 로 설정되어 있다고 가정 - `IPv4 프로토콜(20 bytes)` 과 데이터의 크기가 합쳐진 값 - 따라서, 순수하게 보낼 수 있는 데이터의 크기는 `3,280 bytes`가 된다.
  ⇒ 내가 보내려고 하는 데이터의 크기가 MTU 보다 크므로 그 크기에 맞게 잘게 쪼개어 전송
- 위의 예시에서는 총 4개로 쪼갬
  - MF : 뒤에 더 패킷이 있을 경우 `1`, 없을 경우 `0` ⇒ 마지막 패킷의 값은 `0`
  - Offset : 조각들의 시작 위치를 나타내는 값으로 데이터 크기를 8로 나눈 값이다.
    - `3,280 / 8 = 410`
