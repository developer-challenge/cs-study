# [Chapter 12. 디스크 관리 및 스케쥴링 Part-1](https://core.ewha.ac.kr/publicview/C0101020140523151255773807?vmode=f)

## Disk

![](https://i.imgur.com/b22z3Mb.png)

- 디스크의 물리적인 구조는 마그네틱의 원판으로 구성된다.
  - 하나의 디스크 내에 원판의 수는 하나일 수도 있고 여러 개 일 수도 있다.
- 각각의 원판은 트랙(track)을 구성되고, 각 트랙은 섹터(sector)로 나뉘며, 섹터에 최소한의 단위 정보가 저장된다.
- 여려 개의 원판에서 상대적 위치가 동일한 트랙들의 집합을 실린더(cylinder)라고 부른다.
- 디스크에 데이터를 읽고 쓰기 위해서는 암(arm)이 해당 섹터가 위치한 실린더로 이동한 후 원판이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달해야한다.

#### Logical block(논리블록)

- 디스크의 외부에서 보는 디스크 내의 일정한 크기의 저장공간
- 주소를 가진 1차원 배열처럼 취급
- 정보를 전송하는 최소단위

#### Sector

- 각 논리블록이 저장되는 디스크 내의 불리적인 위치
  - 논리블록 하나가 섹터 하나와 1:1 매핑되어 저장되는 것
- Sector 0은 최외각 실린더의 첫 트랙에 있는 첫 번째 섹터이다.

## Disk Management

#### Physical formatting(Low-level formatting)

- 디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터틀로 나누는 과정
- 각 섹터는 **`header + 실제 data(보통 512 bytes) + trailer`** 로 구성
- header와 trailer에는 sector number, ECC(Error-Correction Code) 등의 정보가 저장되며 컨트롤러가 직접 접근 및 운영
  ⇒ 데이터에는 실제 데이터와 그 데이터에 대한 정보를 가지는 메타데이터가 필요하다. 컨트롤러가 데이터를 읽고, 쓰는 등의 작업을 하다보면 부가적인 정보가 필요하다. 이 부가적인 정보를 헤더와 트레일러에 저장
  - ECC : 데이터를 요약한 코드 같은 것으로 헤더나 트레일러에 저장해둔다. 컨트롤러가 데이터를 꺼내갈 때 헤더와 트레일러를 같이 읽어 거기에 저장되었던 ECC와 실제 데이터에서 생성한 ECC 값을 비교하여 bad sector인지 아닌지를 확인할 수 있다. ECC의 규모에 따라 에러를 확인하는 것 뿐만아니라 수정까지 가능한 경우도 있다.

#### Partitioning

- 디스크를 하나 이상의 실린더 그룹으로 나누는 과정
- Physical formatting 이후 섹터 영역을 묶어주는 작업을 한다.
  ⇒ 운영체제가 이것을 독립적인 디스크로 취급(logical disk)하고 이러한 작업을 파티셔닝이라고 한다.

#### Logical formatting

- Partitioning 이후 각 파티션에 파일 시스템을 만드는 것
- FAT, Inode, free space 등의 구조 포함

#### Booting(부팅 절차)

처음 전원을 켜면 메모리는 모두 비어있는 상태이다. CPU는 메모리만 접근만 할 수 있고 하드디스크는 직접 접근하지 못한다.

- 메모리 영역 중 전원이 나가더라도 내용이 유지되는 소량이 메모리인 ROM에 부팅을 위한 아주 간단한 loader가 저장되어 있다.
- 컴퓨터 전원을 켜면 CPU 제어권이 ROM의 주소를 가리키고, ROM에 있는 "small bootstrap loader"가 실행된다.
- 하드디스크에서 0번 sector에 있는 내용을 메모리에 올리고 실행(loader의 지시)
- sector 0은 "full Bootstrap loader program" 실행
  - full Bootstrap loader program은 파일시스템에서 운영체제 커널의 위치를 찾아 실행하라고 명령
- 운영체제를 디스크에서 load하여 실행한다.

## Disk Scheduling

### 디스크로 접근하는 Access time의 구성

#### Seek time(탐색시간)

- 디스크 헤드가 읽기/쓰기 요청을 한 실린더(트랙)로 이동하는데 걸리는 시간
- 즉 접근하려는 데이터가 원판의 안쪽에 있는지 바깥쪽에 있는지에 따라 헤드를 움직이는 데 걸리는 시간

#### Rotational latency(회전지연시간)

- 디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간
- 탐색시간에 비해 1/10 정도 적은 시간 규모

#### Transfer time(전송시간)

- 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간

⇒ 실제로 전송시간은 매우 적은 시간을 소요한다. 따라서, 접근시간의 대부분은 탐색시간이 차지한다.

### Disk bandwidth

- 단위 시간 당 전송된 바이트의 수

### Disk Scheduling

- 효율적인 디스크 입출력을 위해 여러 섹터들에 대한 입출력 요청이 들어왔을 때 이들을 어떠한 순서로 처리할 것인지 결정하는 메커니즘
- 디스크 스케쥴링의 목표는 탐색시간을 최소화 하는 것
- seek time ≈ seek distance

## Disk Scheduling Algorithm

사실은 스케줄링 알고리즘이 구현되는 곳이 대부분 디스크 내부가 아니기 때문에, (보통 운영체제쪽) 정확한 실린더 위치를 모를 수 있다. 스케줄러는 논리블럭 번호를 보고 스케줄을 하고, 대부분 맞아떨어진다. 내부에서 섹터 단위를 이용하여 스케줄링하는 것도 가능은 하다.

> 큐에 다음과 같은 실린더 위치의 요청이 존재하는 경우 디스크 헤드 53번에서 시작한 각 알고리즘의 수행결과는? (실린더 위치는 0 ~ 199)
> `98, 183, 37, 122, 14, 124, 65, 67`

### FCFS(First Come First Service)

- 디스크에 먼저 들어온 요청을 먼저 처리하는 방식
- 최악의 경우, 양 쪽 끝을 지속적으로 이동하면서 탐색 시간이 매우 늘어나게되어 비효율적인 방법

![](https://i.imgur.com/ubtvhpM.png)

⇒ 총 헤드의 총 이동 : 640 cylinders

### SSTF(Shortest Seek Time First)

- 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘
- 문제점
  - 기아 현상 : 현재의 헤드 위치로부터 가까운 곳에서 지속적인 요청이 들ㄹ어올 경우 헤드 위치에서 멀리 떨어진 곳의 요청은 무한히 기다려야 하는 문제가 발생할 수 있기 때문

![](https://i.imgur.com/oGKvfaa.png)

⇒ 총 헤드의 총 이동 : 236 cylinders

### SCAN

- 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리하는 알고리즘
  - 디스크의 어떠한 위치에 요청이 들어오는가와 상관없이 헤드는 정해진 방향으로 이동하면서 길목에 있는 요청들을 처리하며 지나가는 것
  - 엘리베이터 스케줄링 알고리즘(elevator scheduleing algorithm)이라고도 불린다.
- 디스크 이동거리 측면에서 효율적이다.
- 문제점 : 실린더 위치에 따라 대기시간이 다르다.

![](https://i.imgur.com/2fq8isc.png)

### C-SCAN

- 헤드가 한 쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
- 다른 쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동
- SCAN보다 헤드의 이동거리는 조금 길어지지만 탐색시간의 편차를 줄일 수 있다
  ⇒ 균일한 대기시간을 제공

![](https://i.imgur.com/IxfqioE.png)

### Other Algorithms

#### N-SCAN

- SCAN의 변형 알고리즘
- 일단 암이 한 방향으로 움직이기 시작하면 그 시점 이후에 도착한 프로세스는 되돌아올 때 처리한다.

#### LOOK and C-LOOK

- SCAN이나 C-SCAN은 헤드가 디스크 끝에서 끝으로 이동
- LOOK and C-LOOK은 헤드가 진행 중이다가 그 방향에 더이상 기다리는 요청이 없으면 헤드의 이동방향을 즉시 반대로 이동한다.

![](https://i.imgur.com/jvC4DF3.png)

## Disk-Scheduling Algorithm의 결정

- SCAN, C-SCAN 및 그 응용 알고리즘은 LOOK, C-LOOK 등이 일반적으로 디스크 입출이 많은 시스템에서 효율적인 것으로 알려져 ㅇㅆ음
- file의 할당 방법에 따라 디스크 요청이 영향을 받음
- 디스크 스케줄링 알고리즘은 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 운영체제와 별도의 모듈로 작성되는 것이 바람직하다.

# [Chapter 12. 디스크 관리 및 스케쥴링 Part-2](https://core.ewha.ac.kr/publicview/C0101020140527124647396004?vmode=f)

## Swap-Space Management

#### Disk를 사용하는 두 가지 이유

- 메모리의 휘발성
  ⇒ File system처럼 영속적으로 데이터를 유지해야하는 경우 비휘발성의 Disk를 사용해야한다.
- 프로그램 실행을 위한 메모리 공간 부족
  ⇒ Swap space(swap area) 용도

#### Swap space

- 가상메모리 시스템에서 디스크를 메모리의 연장 공간으로 사용
- 파일 시스템 내부에 둘 수도 있으나 별도의 파티션 사용이 일반적
  - 공간 효율성보다는 속도 효율성이 우선
    ⇒ 프로그램이 실행되는 동안 swap area에 머무르던 프로세스의 주소 공간들은 프로그램 끝나면 사라지게 된다. 물리적 메모리의 연장 공간으로 사용되므로 빠르게 swap in/out이 이루어져야 하므로 속도 효율성을 우선시 한다.
  - 일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조됨
  - 따라서, block의 크기 및 저장 방식이 일반 파일시스템과 다름

## RAID(Redundant Array of Independent Disks)

- 여러 개의 디스크를 묶어서 사용
- 여러 개 디스크에 데이터를 중복 저장하거나 분산 저장한다.

### RAID의 사용 목적

#### 디스크 처리 속도 향상

- 여러 디스크에 block의 내용을 분산 저장
- 병렬적으로 읽어 옴(interleaving, striping)

#### 신뢰성(reliability) 향상

- 동일 정보를 여러 디스크에 중복 저장하여 하나의 디스크가 고장(failure)시 다른 디스크에서 읽어옴(Mirroring, shadowing)
- 단순한 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.
  - parity : 중복 저장의 정도를 대단히 낮게 하여 오류가 발생 여부를 파악하고 복구할 수 있을 정도만의 중복저장을 하는 기법.
