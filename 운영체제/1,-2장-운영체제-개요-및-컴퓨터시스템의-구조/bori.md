영상: [운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

# [Chapter 1. 운영체제 개요](https://core.ewha.ac.kr/publicview/C0101020140307151724641842?vmode=f)

## 운영체제(Operating System, OS)란?

- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층
- 좁은 의미의 운영체제 : 커널, 운영체제의 핵심 부분으로 메모리에 상주하는 부분
- 넓은 의미의 운영체제 : 커널을 포함하여 각종 주변 시스템 유틸리티를 포함한 개념

## 운영 체체의 목적

- 컴퓨터 시스템의 **자원을 효율적으로 관리하는 것**
  - 프로세서, 기억장치, 입출력 장치 등의 효율적 관리(하드웨어 자원)
    - 사용자 간의 형평성 있는 자원 분배
    - 주어진 자원으로 최대한의 성능을 내도록
  - 사용자 및 운영체제 자신의 보호
  - 프로세스, 파일, 메시지 등을 관리(소프트웨어 자원)
- 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
  - 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
  - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

## 운영 체제의 분류

### 동시 작업 가능 여부

- 단일 작업(single tasking) : 한 번에 하나의 작업만 처리
  예) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끄탠기 전에 다른 명령을 수행 시킬 수 없음
- 다중 작업(multi tasking) : 동시에 두 개 이상의 작업 처리
  예) UNIX, MS Window 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

### 사용자의 수

컴퓨터 한 대를 여러 사용자가 동시에 접속하여 사용 가능 여부를 기준으로 분류

- 단일 사용자(single user)
  예) MS-DOS, MS Window
- 다중 사용자(multi user)
  예) UNIX, NT server

### 처리 방식

- 일괄 처리(batch processing)
  - 작업 요청의 일정량 모아서 한꺼번에 처리
  - 작업이 완전히 종료될 때까지 기다려야 함
    예) 초기 Punch Card 처리 시스템
- 시분할(time sharing)
  - 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
  - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
    예) UNIX
  - interactive한 방식
  - 일반 범용 시스템에서 사용
- 실시간(Realtime OS)
  - 정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
    예) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
  - 특수한 목적을 가진 시스템에서 사용
  - 실시간 시스템의 개념 확장
    - Hard realtime system(경성 실시간 시스템) : 데드라인을 정확히 지켜야 하는 시스템
    - Soft realtime system(연성 실시간 시스템) : 데드라인은 있지만 정확히 지켜지지 않아도 치명적이지 않은 시스템

## 몇 가지 용어

- Multi tasking : 여러 작업이 동시에 실행되는 것
- Multi programming : 여러 프로그램이 메모리에 올라가 있음을 강조(메모리 측면을 강조)
- Time sharing : CPU의 시간을 분할하여 나누어 쓴다는 의미 강조(CPU 강조)
- Multi process

위의 용어들은 모두 컴퓨터에서 여러 작업을 동시에 수행하는 것을 의미하지만 각각의 단어들이 강조하는 부분에 차이가 있다.

- Multi processor : 하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미
  ⇒ 하드웨어 적으로 위의 다른 용어들과 차이가 있다.

## 운영 체제의 예

### 유닉스(UNIX)

대형 컴퓨터를 위해 만들어진 운영체제
⇒ 여러 사용자를 동시에 지원을 해주는 운영체제에서 출발

- 코드의 대부분을 C언어로 작성
- 높은 이식성
- 최소한의 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드 공개
- 프로그램 개발에 용이
- 다양한 버전
  - System V, FreeBSD, SunOS, Solaris
  - Linux

### DOS(Disk Operating System)

개인용 컴퓨터를 위해서 만들어진 운영체제
⇒ 단일 사용자를 위해 단일 작업만 지원을 해주는 운영체제에서 출발

- MS 사에서 1981년 IBM-PC를 위해 개발
- 단일 사용자용 운영체제, 메모리 관리 능력이 한계(주 기억장치: 640KB)

### MS Windows

- MS사의 다중 작업용 GUI 기반 운영체제
- Plug and Play, 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 불안정성
- 풍부한 지원 소프트웨어

## 운영 체제의 구조

![](https://i.imgur.com/8dYGEQU.png)

- CPU 스케줄링 : CPU를 어떤 프로세스에 할당해야하는지 관리
- 메모리 관리 : 한정된 메모리를 어떤 프로세스에 얼마만큼 할당해야하는지 관리
- 디스크 파일 관리 : 디스크 파일을 어떤 방법으로 보관할지 관리
- I/O device 관리 : I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리
- 프로세스 관리: 프로세스의 생성, 삭제, 자원 할당 및 반환을 관리

# [Chapter 2. 시스템 구조 및 프로그램의 실행 Part-1](https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f)

## 컴퓨터 시스템 구조

![](https://i.imgur.com/DkOWBwD.png)

컴퓨터 시스템은 크게 CPU와 메모리로 구성된 컴퓨터와 I/O device들로 구성

### Memory

CPU의 작업 공간

### I/O 디바이스

- 입력 장치 : 키보드, 마우스
- 출력 장치 : 프린터, 모니터
- 하드 디스크 : 보조기억장치, 메모리를 읽어들어서 입력 장치의 역할도 하고 처리 결과를 파일 시스템에 저장하는 출력 장치의 역할도 한다.

### Device controller

- I/O device controller
  - 각각의 I/O 디바이스를 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register를 가짐
  - local buffer를 가짐(일종의 data register)
- I/O는 실제 디바이스와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림

> - Device driver(장치 구동기) : OS 코드 중 각 장치별 처리 루틴 ⇒ 소프트웨어
> - Device controller(장치 제어기) : 각 장치를 통제하는 일종의 작은 CPU ⇒ 하드웨어

### Local buffer

메인 CPU의 작업 공간인 메인 메모리가 있듯이 디바이스 컨트롤러들의 작업 공간

### CPU(Central Processing Unit)

매 클럭마다 메모리에서 **\*인스트럭션**을 하나씩 읽어 실행

#### Register

메모리보다 더 빠르면서 정보를 저장할 수 있는 작은 공간으로 CPU 안에 있는 매우 빠른 임시기억장치

#### Mode bit

- CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해주는 역할
- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치 필요
- Mode bit을 통해 하드웨어 적으로 두 가지 모두의 operation 지원
  - `1` : `사용자 모드`, 사용자 프로그램 수행
  - `0` : `모니터 모드`(= `커널 모드`, `시스템 모드`), OS 코드 수행
  - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **특권명령**으로 규정
  - Interrupt나 Exception 발생시 하드웨어가 mode bit를 `0`으로 바꿈
  - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit를 `1`로 세팅

#### Interrup line

CPU는 항상 메모리에 있는 인스트럭션만 실행한다. I/O 디바이스로 인한 신호가 들어왔을 때 CPU에 해당 신호를 전달하는 역할

##### \* 인스트럭션(instruction): 컴퓨터에게 일을 시키는 단위로서, 컴퓨터가 알아들을 수 있는 기계어로 이루어져 있는 명령. 지시 또는 명령이라고 한다.

### Timer

하나의 프로그램이 CPU를 독점하는 것을 막기 위해 시간을 제한하는 하드웨어로 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 하는 역할 수행
⇒ CPU의 time sharing을 구현하기 위해 사용

- 프로그램이 실행되면 타이머에 값을 세팅한 후 프로그램에 CPU를 넘겨준다.
- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 **\*인터럽트**를 발생시킴
- 타이머는 매 클럭 틱 때마다 1씩 감소하고, 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU의 제어권이 프로그램에서 운영체제로 넘어가게 된다.

##### \* 인터럽트(interrupt) : 어떤 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것

### DMA(Direct Memory Access) controller

원칙적으로 메모리에 접근할 수 있는 장치는 CPU 뿐이다. I/O 디바이스가 메모리 접근을 원할 때마다 인터럽트를 발생시키면 CPU의 효율성이 떨어지게 된다. 이러한 비효율성을 해결하기 위해 CPU 이외에 메모리 접근이 가능한 장치를 두는데 이를 DMA controlloer라고 부른다.

- local buffer에서 메모리로 읽어오는 작업을 DMA가 대행하고 인터럽트를 발생시켜 해당 작업의 완료를 알려준다.

⇒ 이러한 방식으로 CPU에 발생하는 인터럽트의 빈도를 줄여 CPU를 좀 더 효율적으로 관리

## 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
  - 사용자 프로그램이 운영체제에게 I/O 요청 ⇒ **시스템콜(System call)**
  - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
  - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 I/O 요청인지 확인 후 I/O 수행
  - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### 시스템 콜 (System Call)

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
- 사용자 프로그램 자신의 코드는 직접 CPU를 가지고 실행하지만, 운영체제 커널에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행하게 되는 것

## 인터럽트(Interrupt)

- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
  - Interrupt : 하드웨어 인터럽트, 하드웨어가 발생시킨 인터럽트
  - Trap : 소프트웨어 인터럽트
    - 예외상황(Exception) : 프로그램이 오류를 범한 경우
    - 시스템 콜(System call) : 프로그램이 커널 함수를 호출하는 경우
- 인터럽트 관련 용어
  - 인터럽트 벡터(interrupt vector) : 해당 인터럽트의 처리 루틴 주소를 가지고 있는 자료구조
  - 인터럽트 처리 루틴(interrupt service routine)/인터럽트 핸들러(interrupt handler) : 해당 인터럽트를 처리하는 커널 함수

# [Chapter 2. 시스템 구조 및 프로그램의 실행 Part-2](https://core.ewha.ac.kr/publicview/C0101020140314151238067290?vmode=f)

## 동기식 입출력과 비동기식 입출력

입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고 받는 것을 말한다.

![](https://i.imgur.com/8SNcRzj.png)

### 동기식 입출력(Synchronous I/O)

- 어떤 프로그램이 입출력 요청을 했을 때 입출력 작업이 완료된 후에야 CPU의 제어권이 사용자 프로그램에 넘어가는 방식
- 구현 방법 1
  - I/O를 요청하고 I/O가 완료될 때까지 다음 명령을 수행할 수 없기 떄문에 그동안 CPU가 낭비된다.
  - 매 시점 하나의 I/O만 일어날 수 있다.
- 구현 방법 2
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
  - 다른 프로그램에게 CPU를 줌

### 비동기식 입출력(Asynchronous I/O)

- 입출력 요청을 한 후 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식

> 동기식 입출력과 비동기식 입출력 모두 I/O의 안료는 인터럽트로 알려준다.

## DMA (Direct Memory Access)

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재없이 device controller가 device의 buffer storage 의 내용을 메모리에 block 단위로 직접 전송
- byte 단위가 아닌 block 단위로 인터럽트 발생시킴

## 서로 다른 입출력 명령어

![](https://i.imgur.com/uQM7EFd.png)

### 일반적인 I/O 방식

- CPU에서 실행할 수 있는 인스트럭션에는 메모리만 접근하는 인스트럭션과 I/O 장치에만 접근하는 인스트럭션으로 구분되어 있다.

### Memory Mapped I/O 방식

- I/O 장치에 메모리 주소의 연장 주소를 붙여 메모리에 접근하는 인스트럭션을 통해 I/O를 하는 방식

## 저장장치 계층 구조

![](https://i.imgur.com/8fer4TF.png)

컴퓨터 시스템을 구성하는 저장장치는 빠른 저장장치부터 느린 저장장치까지 단계적인 계층 구조로 이루어진다.
저장장치 계층 구조에서 위로 갈수록 속도가 빠르고, 단위 공간당 가격이 비싸고, 용량이 적다.

- Primary(Executable) : 휘발성 저장장치, CPU에서 직접 접근할 수 있는 스토리지 매체
  - Registers
  - Cache Memory
  - Main Memory
- Secondary : 비휘발성 저장장치, CPU에서 직접 접근할 수 없다.
  - Magnetic Disk
  - Optical Disk
  - Magnetic Tape

### 캐싱 기법(caching)

- 재사용을 목적으로하는 기법으로 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총제적 기법
- 상대적으로 느린 저장장치에 있는 내용 중 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장함으로써 두 저장장치 사이의 속도를 완충시킨다.

## 프로그램의 실행 (메모리 load)

프로그램이라는 것은 실행파일 형태로 하드디스크에 저장되어 있고, 이 파일을 실행하면 메모리로 올라가서 프로세스가 된다. 그러나 물리적 메모리에 프로그램이 바로 올라가는 것이 아니라 중간에 가상메모리 단계를 거치게 된다.

사용자 프로그램을 실행시키면 0번지부터 시작하는 독자적인 주소 공간을 생성하는데 이 메모리 공간을 가상메모리라고 부른다.

- 가상메모리(virtual memory) : 프로그램마다 독자적으로 가지고 있는 메모리 주소 공간
  - code : CPU에서 실행할 기계어 코드
  - data : 프로그램에서 사용하는 자료구조(예: 변수)
  - stack : 코드 내에서 함수호출 및 복귀 주소를 유지하기 위한 공간

이 주소 공간을 가상메모리에서 물리적 메모리로 올린다.
프로그램의 주소 공간을 전부 물리적 메모리에 올리는 것이 아니라 당장 CPU 수행에 필요한 부분만 물리적 메모리에 올려놓고 그렇지 않은 부분은 스왑 영역에 내려놓는다.
⇒ 메모리 공간을 효율적으로 사용하기 위한 방법

- 스왑 영역(swap area) : 메인 메모리의 연장 공간으로 하드디스크를 사용하는 영역. 전원이 나가면 프로세스가 종료되면서 메모리의 내용이 사라진다.(휘발성)
- 파일 시스템 : 전원이 나가더라도 파일의 내용이 유지된다.(비휘발성)
- 메모리 주소 변환(address translation) : 가상메모리 주소를 물리적인 메모리 주소로 변환

## 커널 주소 공간의 내용

![](https://i.imgur.com/POQRQm5.png)

운영체제도 하나의 프로그램이므로 운영체제 커널도 코드, 데이터, 스택의 주소 공간 구성을 가지고 있다.

#### 커널의 코드

운영체제의 기능이 하드웨어 자원을 효율적으로 관리하는 것과 응용 프로그램 및 사용자에게 편리한 서비스를 제공하는 것이므로

- CPU 자원을 관리하기 위한 코드
- 사용자에게 편리한 인터페이스를 제공하기 위한 코드
- 시스템 콜 및 인터럽트를 처리하기 위한 코드

#### 커널의 데이터

운영체제가 사용하는 각종 자원을 관리하기 위한 자료구조 저장

#### 커널의 스택

운영체제도 함수 구조로 짜여져 있기 때문에 함수를 호출하거나 반환할 때 스택 영역을 사용한다.

- 함수호출 시의 복귀 주소를 저장하기 위한 용도로 사용
- 일반 사용자 프로그램의 스택과 달리 현재 수행 중인 프로세스마다 별도의 스택을 두어 관리

## 사용자 프로그램이 사용하는 함수

### 함수(function)

크게 사용자 정의 함수, 라이브러리 함수, 커널 함수로 구분

#### 사용자 정의 함수

- 프로그래머 본인이 프로그램에 직접 정의한 함수

#### 라이브러리 함수

- 프로그래머 본인이 직접 정의하지 않고 이미 누군가 작성해놓은 함수를 호출하여 사용
- 자신의 프로그램의 실행 파일에 포함되어 있다.

⇒ 이 두 함수는 프로그램이 실행될 때 해당 프로세스의 주소 공간에 포함되며, 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.

#### 커널 함수

- 운영체제 프로그램에 정의된 함수
- 커널 함수는 시스템 콜을 통해 호출하여 사용

⇒ 커널 함수는 사용자 프로그램의 주소 공간에 존재하는 것이 아니라 운영체제 커널의 주소 공간에 코드가 정의된다.

## 프로그램의 실행

![](https://i.imgur.com/6HG4sew.png)

사용자 모드에서의 실행 상태와 커널 모드의 실행 상태로 나눌 수 있다.

- 사용자 모드(user mode) : 자신의 주소 공간에 정의된 코드를 실행하는 것
- 커널 모드(kernel mode) : 커널의 시스템 콜 함수를 실행하는 것

#### 프로그램의 실행 과정

- 프로그램이 시작되어 종료될 때까지 사용자 모드와 커널 모드의 실행 상태로 구분할 수 있다.
- 프로그램이 사용자 정의함수나 라이브러리 함수를 호출할 때에는 모드의 변경 없이 사용자 모드에서이 실행이 지속되고, 시스템 콜을 하는 경우 커널 모드에 진입해 커널의 주소 공간에 정의된 함수를 실행한다.
- 시스템 콜의 실행이 끝나면 다시 사용자 모드로 복귀해서 시스탬 콜 이후의 명령들을 이어간다.
- 프로그램의 실행이 끝날 때에는 커널모드로 진입해 프로그램을 종료한다.

⇒ 프로그램은 시작할 때부터 종료될 때까지 사용자 모드와 커널 모드를 반복
