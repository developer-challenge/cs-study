영상: [운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

## [1 운영체제 개요](https://core.ewha.ac.kr/publicview/C0101020140307151724641842?vmode=f)

### 운영 체제란?

![](https://i.imgur.com/rqZ7sfP.png)

컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

- 좁은 의미의 운영체제(커널)
  - 운영체제의 핵심 부분으로 메모리에 상주하는 부분
- 넓은 의미의 운영체제
  - 커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

### 운영 체체의 목적

컴퓨터 시스템의 **자원을 효율적으로 관리**

- 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
  - 사용자간의 형평성 있는 자원 분배
  - 주어진 자원으로 최대한의 성능을 내도록
- 사용자 및 운영체제 자신의 보호
- 프로세스, 파일, 메시지 등을 관리

**컴퓨터 시스템을 편리하게 사용할 수 있는 환경**을 제공

- 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
- 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행

### 운영 체제의 분류

**동시 작업 가능 여부**

단일 작업(single tasking)

- 한 번에 하나의 작업만 처리
  ex) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음

다중 작업(multi tasking)

- 동시에 두 개 이상의 작업 처리
  ex) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음

****\*\*****\*\*\*\*****\*\*****사용자의 수****\*\*****\*\*\*\*****\*\*****

단일 사용자(single user)

ex) MS-DOS, MS Windows

다중 사용자(multi user)

ex) UNIX, NT server

**\*\*\*\***\*\***\*\*\*\***처리 방식**\*\*\*\***\*\***\*\*\*\***

![](https://i.imgur.com/sD9ycAZ.png)

일괄 처리(batch processing)

- **작업 요청의 일정량 모아서 한꺼번에 처리**
- 작업이 완전 종료될 때까지 기다려야 함
  ex) 초기 Punch Card 처리 시스템

![](https://i.imgur.com/83t1cCD.png)

시분할(time sharing)

- 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 **시간 단위로 분할**하여 사용
- 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐
  ex) UNIX
- interactive한 방식

실시간(Realtime OS)

- **정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장**되어야 하는 실시간 시스템을 위한 OS
  ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
- 실시간 시스템의 개념 확장
  - Hard realtime system(경성 실시간 시스템) - 데드라인을 엄격히 지키지 않으면 치명적인 결과를 초래
  - Soft realtime system(연성 실시간 시스템) - 데드라인은 있지만 치명적인 결과를 초래하지 않는 시스템 (ex.영화, 멀티미디어 플레이..)

### 몇 가지 용어

Multitasking

Multiprogramming

Time sharing

Multiprocess

**컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻함**

- Multiprogramming은 여러 프로그램이 메모리에 올라가 있음을 강조
- Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조

Multiprocessor

- 하나의 컴퓨터에 CPU(processor)가 여러 개 붙어 있음을 의미

### 운영 체제의 예

**유닉스(UNIX)**

- 코드의 대부분을 C언어로 작성
  - 기계어로 가까운 언어로 프로그래밍 하기 어렵기 때문에 C언어를 만듦
- 높은 이식성
  - 기계어와 독립적인 C언어로 작성되어 있어 다른 컴퓨터에서 컴파일하면 실행 가능
- 최소한의 커널 구조
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드 공개
- 프로그램 개발에 용이
- 다양한 버전
  - System V, FreeBSD, SunOS, Solaris
  - Linux

DOS(Disk Operating System)

- MS사에서 1981년 IBM-PC를 위해 개발
- 단일 사용자용 운영체제, 메모리 관리 능력의 한계(주 기억 장치 : 640KB)

MS Windows

- MS사의 다중 작업용 GUI 기반 운영 체제
- Plug and Play, 네트워크 환경 강화
- DOS용 응용 프로그램과 호환성 제공
- 풍부한 지원 소프트웨어

### 운영 체제의 구조

![](https://i.imgur.com/lmrZXlU.png)

## [2 시스템 구조 및 프로그램의 실행 Part-1](https://core.ewha.ac.kr/publicview/C0101020140311132925816476?vmode=f)

### 컴퓨터 시스템 구조

![](https://i.imgur.com/kzkoaCa.png)

CPU의 작업 공간이 Memory이기 때문에 CPU는 매 순간(clock cycle)마다 Memory에서 인스트럭션(기계어)를 읽어서 실행

PC(Program Counter)레지스터가 다음 실행할 인스트럭션 주소를 갖고 있음

![](https://i.imgur.com/6HWgJk9.png)

CPU는 Memory에 접근하여 인스트럭션을 실행하다가 IO 디바이스가 필요한 경우 device controller에 일을 시킴(일을 시키는 인스트럭션), 인스트럭션이 끝나면 인터럽트 라인 체크

1.  CPU보다 상대적으로 느리기 때문에 local buffer에 시킨 일을 넣음
2.  CPU는 대기하지 않고 계속해서 메모리 접근하여 인스트럭션 실행
3.  IO 디바이스에서 실행한 값이 필요한데 아직 전달되지 않은 경우 CPU는 다른 프로그램으로 넘어감

IO 장치로 접근하는 모든 인스트럭션은 운영체제를 통해서만 할 수 있음 → 사용자 프로그램은 직접 IO장치에 접근할 수 없음

1.  IO 작업이 필요할 경우 스스로 운영체제에 CPU를 넘겨줌
2.  IO 작업이 오래걸리기 때문에 운영체제는 IO 작업을 요구한 프로그램이 아닌 다른 프로그램에 CPU를 넘겨줌
3.  IO 작업이 완료되어 buffer에 들어오면 controller가 CPU에 인터럽트를 요청
4.  인터럽트가 들어오면 CPU제어권이 운영체제로 넘어감
5.  운영체제는 IO 작업 후 입력된 값을 IO 작업을 요청한 프로그램의 메모리 공간에 카피
6.  인터럽트로 인해 중단된 프로그램에 다시 CPU를 넘겨줌
7.  프로그램이 실행되고 언젠가는 IO 작업을 요청한 프로그램이 다시 CPU를 얻게 됨

### Interrupt line

컴퓨터에 붙어있는 주변기기(IO 디바이스)가 CPU에게 어떠한 사실을 알리는 인터럽트 요구 신호

CPU는 인스트럭션을 하나씩 실행하다가 하나의 인스트럭션이 끝나게 되면 인터럽트 라인 체크

→ 타이머가 인터럽트를 걸었으면 CPU는 하던 일을 멈추고 제어권이 사용자 프로그램으로부터 운영체제로 넘어감

### Mode bit

CPU에서 실행되고 있는 것이 **운영체제인지 사용자 프로그램인지 구분**해 주는 것

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요
- Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원
  - **1 사용자 모드** : 사용자 프로그램 수행
  - **0 모니터 모드(커널 모드, 시스템 모드)** : OS 코드 수행
    - **보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능**한 “특권명령”으로 규정
    - Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅

### Timer

특정 프로그램이 CPU를 독점하는 것을 막기 위함

처음(컴퓨터를 켰을 때)에는 운영체제가 CPU를 사용하고, 여러 사용자 프로그램이 실행되면 CPU를 넘겨줌 → 이 때 Timer에 값을 세팅한 뒤 넘겨줌

- **정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴**
- 타이머는 매 클럭 틱 때마다 1씩 감소
- 타이머 값이 0이 되면 타이머 인터럽트 발생
- CPU를 특정 프로그램이 독점하는 것으로부터 보호

타이머는 time sharing을 구현하기 위해 널리 이용됨

타이머는 현재 시간을 계산하기 위해서도 사용

### Device Controller

각각의 I/O 디바이스를 전담, 통제하는 작은 CPU 같은 것

local buffer : device controller의 작업공간

- 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
- 제어 정보를 위해 control register, status register를 가짐
- local buffer를 가짐(일종의 data register)

I/O는 실제 device와 local buffer 사이에서 일어남

Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

device driver(장치구동기) : OS 코드 중 각 장치별 처리루틴 → software

device controller(장치제어기) : 각 장치를 통제하는 일종의 작은 CPU → hardware

### DMA controller

직접 메모리 접근(Direct Memory Access)

IO 디바이스의 buffer 내용을 Memory에 복사해주고 CPU에 인터럽트를 한 번만 요청하는 역할

→ CPU가 중간에 인터럽트 당하는 빈도가 줄어들어 효율성 높아짐

CPU와 DMA controller가 동시에 메모리에 접근하는 것을 방지하기 위해 Memory controller가 조율

### [입출력과 인터럽트 (Input-Output and Interrupt)](/컴퓨터-구조/5장-기본-컴퓨터의-구조와-설계-Part2/입출력과-인터럽트.md)

### 인터럽트

인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘김

- **Interrupt (하드웨어 인터럽트)** : 하드웨어가 발생시킨 인터럽트
- **Trap (소프트웨어 인터럽트)**
  - Exception : 프로그램이 오류를 범한 경우
  - System call : 프로그램이 커널 함수를 호출하는 경우

인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음

인터럽트 처리 루틴(인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수

**현대의 운영체제는 인터럽트에 의해 구동됨**

### 입출력(I/O)의 수행

모든 입출력 명령은 특권 명령

사용자 프로그램은 어떻게 I/O를 하는가?

- 시스템콜(system call)
  - 사용자 프로그램이 운영체제에게 I/O 요청
- trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
- 올바른 I/O 요청인지 확인 후 I/O 수행
- I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### 시스템 콜 (System Call)

사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

⇒ mode bit이 1이기 때문에 사용자 프로그램에서 바로 운영체제에 접근이 허용되지 않음 → 사용자 프로그램이 직접 인터럽트 라인을 세팅하는 인스트럭션 실행

## [2 시스템 구조 및 프로그램의 실행 Part-2](https://core.ewha.ac.kr/publicview/C0101020140314151238067290?vmode=f)

### 동기식 입출력과 비동기식 입출력

![](https://i.imgur.com/5pAwePM.png)

********\*\*********\*\*\*\*********\*\*********동기식 입출력 (synchronous I/O)********\*\*********\*\*\*\*********\*\*********

- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
- 구현 방법 1
  - I/O가 끝날 때까지 CPU를 낭비시킴
  - 매시점 하나의 I/O만 일어날 수 있음
- 구현 방법 2
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
  - 다른 프로그램에게 CPU를 줌

******\*\*******\*\*******\*\*******비동기식 입출력 (asynchronous I/O)******\*\*******\*\*******\*\*******

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

두 경우 모두 I/O의 완료는 인터럽트로 알려줌

### DMA (Direct Memory Access)

- (빠른) **입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용**
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

### 서로 다른 입출력 명령어

![](https://i.imgur.com/PBpMaRl.png)

좌측 : I/O를 수행하는 special instruction

우측 : Memory Mapped I/O - I/O장치도 메모리 주소에 연장주소를 붙여서 접근

### 저장장치 계층 구조

![](https://i.imgur.com/ZKjkyUn.png)

**Primary(Executable)**

CPU에서 직접 접근할 수 있는 메모리 매체(실행가능)

→ 바이트 단위로 접근 가능

**Secondary**

CPU에서 직접 접근할 수 없는 메모리 메체

→ 섹터단위로 접근

### 프로그램의 실행 (메모리 load)

![](https://i.imgur.com/gmUlfhO.png)

1. 프로그램 실행
2. 0번지 부터 시작하는 실행시킨 프로그램만의 독자적인 Address space(메모리 주소 공간)이 형성됨
   1. 주소 공간은 code, data, stack영역으로 구성
      1. code : CPU가 실행할 기계어 코드
      2. data : 변수, 전역변수와 같은 프로그램이 사용하는 자료구조
      3. stack : 코드가 함수 구조로 되어있기 때문에 함수를 호출하거나 리턴할 때 데이터를 스택형식으로 사용
3. 물리적인 메모리 공간에 올려서 실행 시킴
   1. 프로그램을 실행시켰을 때 생성되는 주소 공간(Address space)을 메모리 낭비 문제로 인해 물리적인 메모리에 전부 올리지 않음 → 당장 필요한 부분(ex. 실행하고 있는 A 함수)만 물리적인 메모리에 올림
   2. 사용되지 않는 것들은 다시 제거
4. 당장 필요하지 않은 부분은 물리적인 메모리가 아닌 디스크(Swap area - 물리적인 메모리 연장공간으로써 사용)에 내려놓음

Address translation : 주소 변환 계층(하드웨어)에서 Virtual memory(논리적인 주소)를 Physical memory(물리적인 주소)로 변환

### 커널 주소 공간의 내용

![](https://i.imgur.com/ulWo0hX.png)

PCB(Process Control Block) : 실행 중인 프로세스를 관리하기 위한 자료구조

### 사용자 프로그램이 사용하는 함수

**사용자 정의 함수**

- 자신의 프로그램에서 정의한 함수

******\*\*\*\*******\*\*******\*\*\*\*******라이브러리 함수******\*\*\*\*******\*\*******\*\*\*\*******

- 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
- 자신의 프로그램의 실행 파일에 포함

Virtual memory 프로세스 Address space의 code

---

**\*\*\*\***\*\***\*\*\*\***커널 함수**\*\*\*\***\*\***\*\*\*\***

- 운영체제 프로그램의 함수
- 커널 함수의 호출 = 시스템 콜

Virtual memory 커널 Address space의 code

### 프로그램의 실행

![](https://i.imgur.com/1DzQepY.png)

프로그램이 CPU 사용 → user mode

system call → kernel mode
