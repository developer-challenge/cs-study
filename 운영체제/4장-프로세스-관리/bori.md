# [Chapter 4. 프로세스 관리 Part-1](https://core.ewha.ac.kr/publicview/C0101020140321144554159683?vmode=f)

## 프로세스 생성 (Process Creation)

- 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스(부모 프로세스)가 다른 프로세스(자식 프로세스)를 복제 생성하게 된다.
  ⇒ 여기서 복제는 프로세스 문맥을 모두 복사하는 것을 의미
  - 부모 프로세스(parent process) : 프로세스를 생성한 프로세스
  - 자식 프로세스(children process) : 새롭게 생성된 프로세스
- 프로세스의 트리(계층 구조) 형성

#### 자원을 획득하는 방법

프로세스는 작업을 수행하기 위해 자원을 필요로 한다.

- 운영체제로부터 직접 자원을 할당 받는다.
- 부모와 자원을 공유한다.

#### 자원의 공유

- 부모와 자식이 모든 자원을 공유하는 모델
- 일부를 공유하는 모델
- 전혀 공유하지 않는 모델
  ⇒ 프로세스가 생성이 되면 서로 독립적인 프로세스이므로 원칙적으로는 자원을 공유하지 않는다.

> #### Copy-on-write(COW)
>
> - write가 발생했을 때 copy를 하겠다는 의미
> - write가 발생했다는 것은 원래 있던 내용이 비뀌는 것으로 내용이 바뀔 때 내용을 copy하여 새로운 것을 만든다.
> - 내용이 바뀌기 전까지는 부모의 자원을 공유한다.

#### 실행(execution)

- 부모와 자식은 공존하며 수행되는 모델
  ⇒ 프로세스가 생성되면 각각은 별도의 프로세스이기 때문에 CPU를 얻기 위한 경쟁 관계가 된다.
- 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델
  ⇒ 자식 프로세스가 종료될 때가지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가, 자식 프로세스가 종료되면 그때 부모 프로세스가 준비 상태가 되어 다시 CPU를 얻을 권한이 생기게 된다.

#### 주소 공간(address space)

프로세스가 생성되면 자신만의 독자적인 주소 공간을 갖는다.

- 자식은 부모의 주소 공간을 복사하여(binary and OS data) 생성
- 자식이 다른 프로그램을 수행하기 위해 그 주소 공간에 새로운 프로그램의 주소 공간을 덮어씌워 실행

#### 유닉스의 예를 통한 프로세스의 생성 절차

- `fork()` 시스템 콜을 통해 새로운 프로세스 생성
  - 부모 프로세스의 내용을 그대로 복사하여 생성(OS data except PID + binary)
  - 주소 공간 할당
- `fork()` 를 통해 생성된 자식 프로세스는 `exec()` 시스템 콜을 통해 새로운 프로그램을 메모리(주소 공간)에 올림

## 프로세스 종료 (Process Termination)

원칙적으로 부모 프로세스가 종료되기 전에 그 아래에 존재하는 모든 자식 프로세스들이 먼저 종료되어야 한다.

#### 자발적 종료(exit)

프로세스가 마지막 명령을 수행한 후 `exit()` 시스템 콜을 넣어 운영체제에게 자신이 종료됨을 알려준다.

- 프로세스가 종료될 때 자식이 부모에게 output data를 보냄(`wait()` 시스템 콜을 통해)
- 프로세스의 각종 자원들이 운영체제에게 반납됨

#### 비자발적 종료(abort)

부모 프로세스가 자식의 수행을 강제로 종료시키는 것

- 자식이 할당 자원의 한계치를 넘어섬
- 자식에게 할당된 태스크가 더 이상 필요하지 않은 경우
- 부모 프로세스가 종료(exit)되는 경우
  - 운영체제는 부모 프로세스가 종료되는 경우 자식이 더 이상 수행되지 못하게 한다.
  - 단계적인 종료가 발생

# [Chapter 4. 프로세스 관리 Part-2](https://core.ewha.ac.kr/publicview/C0101020140325134428879622?vmode=f)

## 프로세스와 관련한 시스템콜

| 시스템 콜 | 설명                                   |
| --------- | -------------------------------------- |
| `fork()`  | Create a child(copy)                   |
| `exec()`  | Overlay new image                      |
| `wait()`  | Sleep until child is done              |
| `exit()`  | Frees all the resources, notify parent |

### `fork()` 시스템 콜

`fork()`를 통해 생성된 프로세스는 **부모 프로세스의 모든 문맥을 그대로 복제**해 자식 프로세스의 문맥을 형성
⇒ 자식은 부모의 처음부터 수행을 시작하는 것이 아니라 부모가 현재 수행한 시점(프로그램 카운터 지점)부터 수행하게 된다.

```clike
int main()
{
  int pid;
  pid = fork();
  if(pid == 0) /* this is child */
    printf("\n Hello, I am child!\n");
  else if (pid > 0) /* this is parent */
    printf("\n Hello, I am parent!\n");
}
```

| 구분              | 부모 프로세스 | 자식 프로세스 |
| ----------------- | ------------- | ------------- |
| `fork()`의 결과값 | `pid` > 0     | `pid` = 0     |

- 부모가 메인 함수의 첫 번째 불부터 한 줄씩 코드를 수행하다가 `fork()` 라인에 이르면 자신과 똑같은 프로세스를 하나 생성
  ⇒ 현재 그 라인까지 수행했다는 기억(프로그램 카운터 값)조차 똑같은 자식 프로세스가 생성
- `fork()` 함수의 결과값을 통해 부모와 자식 프로세스를 구분
  - 원본(부모 프로세스) : 양수
  - 복제본(자식 프로세스) : `0`
- 따라서 조건문을 통해 부모와 자식 프로세스가 다른 작업을 하도록 프로그램 작성
- 조건문을 통해 부모와 자식 프로세스에게 다른 작업을 수행시킬 수 있지만 사실상 두 프로세스 모두 동일한 코드의 내용을 가지고 있다. 따라서 각 프로세스가 다른 독자적인 프로그램을 수행시킬 수 있는 메커니즘이 필요하다.
  ⇒ `exec()` 시스템 콜

### `exec()` 시스템 콜

```clike
int main()
{
  int pid;
  pid = fork();
  if(pid == 0) /* this is child */
  {
    printf("\n Hello, I am child!\n");
    // execlp : 일종의 함수로 exec() 시스템 콜을 한다.
    execlp("/bin/date", "/bin/date", (char*)0);
  }

  else if (pid > 0) /* this is parent */
    printf("\n Hello, I am parent!\n");
}
```

- `exec()` 시스템 콜을 하게 되면 새로운 프로그램으로 완전히 덮어씌워진다.
- 그 후 새로운 프로그램의 시작부터 다시 실행한다.
- `exec()` 을 하게되면 다시 되돌아올 수 없다.

#### `fork()` 없이 진행되는 `exec()` 시스템 콜

```clike
int main()
{
  printf("\n Hello, I am child!\n");
  execlp("/bin/date", "/bin/date", (char*)0);
  // exec 이후의 코드는 실행되지 않는다.
  printf("\n Hello, I am parent!\n");
}
```

- "Hello, I am child"를 출력 후 `exec()` 시스템 콜에 의해 새로운 프로그램으로 덮어씌워진다.
- `exec()` 이후의 코드는 실행이 불가하다.

### `wait()` 시스템 콜

부모 프로세스가 `wait()` 시스템 콜을 호출하면,

- 커널은 자식이 종료될 때까지 부모 프로세스를 sleep 시킨다.
  ⇒ CPU를 얻지 못한 block 상태가 된다.
- 자식이 종료되면 커널은 부모 프로세스를 깨운다.
  ⇒ 부모 프로세스를 ready 상태로 변경시켜 작업을 재개할 수 있도록 한다.

```clike
int main()
{
  int childPID;
  childPID = fork();
  if(childPID == 0) { /* this is child */
    // 자식 프로세스가 수행할 코드
  }
  else { /* this is parent */
    wait();
  }

  // 다음 수행할 코드
}
```

- `fork()` 이후 `fork()` 의 결과값을 통해 자식 프로세스가 수행할 코드와 부모가 수행할 코드를 분기처리
- 부모가 수행할 코드에 `wait()` 시스템 콜을 넣어주게 되면, 부모는 block상태가 되어 CPU를 얻지 못하고 자식 프로세스가 종료될 때까지 기다리게 된다.
- 자식이 종료되면 `wait()` 시스템 콜을 빠져나가서 다음 코드를 실행할 수 있게 된다.

⇒ `wait()` 시스템 콜을 하게 되면, 프로세스가 수행되는 모델이 **자식이 종료될때까지 부모가 기다리는 모델**에 해당이 된다.

### `exit()` 시스템 콜

프로세스를 종료시킬 때 호출하는 시스템 콜

#### 자발적 종료

- 마지막 statement 수행 후 exit() 시스템 콜을 통해 프로세스 종료
- 프로그램에 명시적으로 작성하지 않아도 main 함수가 리턴되는 위치에 컴파일러가 자동으로 삽입한다.

#### 비자발적 종료

- 부모 프로세스가 자식 프로세스를 강제 종료시킴
  - 자식 프로세스가 한계치를 넘어서는 자원을 요청
  - 자식에게 할당된 태스크가 더 이상 필요하지 않음
- 키보드로 `kill`, `break` 등을 친 경우
- 부모가 종료하는 경우
  - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

## 프로세스 간 협력

### 독립적인 프로세스(Independent process)

프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
⇒ 경우에 따라서 독립적인 프로세스들이 협력할 때 더 효율적이기도 하다.

### 협력 프로세스(Cooperating process)

프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

## 프로세스 간 협력 메커니즘(IPC, Inter-Process Communication)

프로세스 간에 정보를 주고받을 수 있는 방법

![](https://i.imgur.com/m92q8Ow.png)

### Message passing(메시지 전달 방식)

#### Message system

- 프로세스 간에 공유 데이터(shared variable)를 일체 사용하지 않고 메시지를 주고 받으면서 통신하는 시스템
- 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접할 수 없으므로 커널을 통해 메시지 전달

#### 메시지 통신 방법

메시지의 전송 대상이 다른 프로세스인지 아니면 메일박스라는 일종의 저장공간인지에 따라 구분

- Direct Communication(직접통신) : 통신하려는 프로세스의 이름을 명시적으로 표시
  ![](https://i.imgur.com/Mv0IkMT.png)
- Indirect Communication(간접통신) : 메일박스(mailbox) 또는 포트(port)를 통해 메시지를 전달 받는다.
  ![](https://i.imgur.com/sFe6H7r.png)

### Shared Memory(공유 메모리 방식)

서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있다.

- 운영체제는 공유 메모리를 사용하는 시스템 콜을 지원
- 각 프로세스의 주소 공간이 독립적으로 있으나 물리적인 메모리에 매핑을 할 때 공유 메모리 주소 영역에 대해 동일한 물리적 메모리 주소로 매핑되는 것
- 이 방식은 프로세스 간의 통신을 수월하게 만드는 인터페이스를 제공하지만 서로의 데이터에 일관성 문제가 유발될 수 있으므로 유의해야 한다.

> #### Thread
>
> 스레드는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기 어렵지만 동일한 프로세스를 구성하는 스레드들 간에는 주소 공간을 공유하므로 협력이 가능하다.

# Chapter 5. CPU 스케줄링

## CPU and I/O Bursts in Program Execution

사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복으로 구성된다.

![](https://i.imgur.com/hc7ETxt.png)

- CPU burst : 사용자 프로그램이 직접 CPU를 가지고 명령을 수행하는 단계
  - CPU에서 인스트럭션을 실행하는 명령어 : load 명령, store 명령 등
- I/O burst : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 단계
- 프로그램 종류에 따라서 CPU burst 와 I/O burst가 차지하는 비율이 다르다.

## CPU-burst Time의 분포

![](https://i.imgur.com/xJVmUtF.png)

- 여러 종류의 job(= process)이 섞여 있기 대문에 CPU 스케줄링이 필요하다.
  - I/O bound job은 사용자와 인터랙션을 해가며 프로그램을 수행한다.
    ⇒ 대화형 작업이므로 사용자에게 빠른 응답이 중요하므로 CPU 스케줄링을 할 때 interactive job에게 우선적으로 CPU를 사용할 수 있도록 하는 스케줄링이 필요하다.
  - CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용

## 프로세스의 특성 분류

#### I/O bound process

- CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job
- 대부분 짧은 CPU 버스트로 구성(many short CPU bursts)
- I/O 요청이 빈번하여 CPU 버스트가 짧게 나타나는 작업
  ⇒ 주로 사용자로부터 인터랙션을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램에 해당

#### CPU bound process

- 계산 위주의 job
- 소수의 긴 CPU 버스트로 구성(few very long CPU bursts)
- I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 작업
  ⇒ 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램에 해당

## CPU Scheduler & Dispatcher

### CPU Scheduler

- 준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드
- 독립적인 하드웨어나 소프트웨어가 아닌 운영체제 안에서 CPU 스케줄링을 하는 코드를 CPU Scheduler라고 부른다.

#### CPU 스케줄링이 필요한 경우

다음과 같은 상태 변화가 있을 때 CPU 스케줄링이 필요하다.

1. `Running → Blocked` : 실행 상태의 프로세스가 I/O 요청하는 시스템 콜에 의해 봉쇄 상태로 바뀌는 경우
2. `Running → Ready` : 실행 상태의 프로세스가 timer interrupt에 의해 준비 상태로 바뀌는 경우
3. `Blocked → Ready` : I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 프로세스가 준비 상태로 바뀌는 경우
4. `Terminate` : CPU에서 실행 상태에 있는 프로세스가 종료되는 경우

- 1번과 4번의 경우, CPU를 가지고 있어도 인스트럭션을 실행할 수 없는 상태이므로 자진 반납하는 경우이다.
  ⇒ **비선점형(nonpreemptive)** 방식으로 CPU를 획득한 프로세스가 강제로 빼앗기지 않고 자진 반납하는 방법
- 2번과 3번의 경우, **선점형(preemptive)** 방식으로 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법

### Dispatcher

- CPU Scheduler가 어떤 프로세스에게 CPU를 할당할지 결정한 후 선택된 프로세스에게 CPU의 제어권을 넘겨주는 역할을 하는 운영체제의 코드
- 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정 수행
  ⇒ 이 과정을 문맥 교환이라고 한다.
